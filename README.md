# enum-update
[![Crates.io Version](https://img.shields.io/crates/v/enum-update?label=crates.io)](https://crates.io/crates/enum-update) [![docs.rs](https://img.shields.io/docsrs/enum-update)](https://docs.rs/enum-update/latest/enum_update/) [![GitHub License](https://img.shields.io/github/license/Eisverygoodletter/enum-update)](LICENSE) [![GitHub contributors](https://img.shields.io/github/contributors/Eisverygoodletter/enum-update)](#)

`enum-update` is a set of macros and traits for representing state changes as enums.

> Note: `enum-update` is currently at `v0.1.0` and is not at stable `v1.0.0` yet. Overall functionality should stay the same, but trait and macro names may change between versions.

# Adding `enum-update` to your project

Import `enum-update` into your project by running this command.
```sh
cargo add enum-update
```
All `enum-update-derive` macros are re-exported by `enum-update`. There is no need to manually add `enum-update-derive` to your project dependency list.

# Macros

The following derive macros are provided by `enum-update`

| Derive macro | Description |
| ---   | ----------- |
| `EnumUpdate` | Creates a new enum representing updates to a struct |
| `EnumUpdateSetters` | Add setter methods to a struct that also return enums generated by `EnumUpdate` |

# Examples
## `EnumUpdate`

### Basic example

```rust
use enum_update::*;
#[derive(Debug, PartialEq, EnumUpdate)]
pub struct MyState {
    #[variant_group]
    value: String,
    #[variant_group]
    another_value: u32,
}
// `EnumUpdate` will generate:
// pub enum MyStateUpdate {
//     Value { value: String },
//     AnotherValue { value: u32 },
// }
// impl EnumUpdate<MyStateUpdate> for MyState {
//     fn apply(&mut self, update: MyStateUpdate) {
//         match update {
//             MyStateUpdate::Value { value } => {
//                 self.value = value;
//             },
//             MyStateUpdate::AnotherValue { another_value } => {
//                 self.another_value = another_value;
//             }
//         }
//     }
// }
let mut state = MyState {
    value: "initial_string_value".to_string(),
    another_value: 123,
};
let first_change = MyStateUpdate::Value("new string value".to_string());
state.apply(first_change);
assert_eq!(state, MyState {
    value: "new string value".to_string(),
    another_value: 123
});
```
### Overlapping variant groups

Applying the same variant group on multiple fields will group them together
```rust
#[derive(EnumUpdate)]
pub struct OverallState {
    #[variant_group(SensorAInput)]
    speed: i32,
    #[variant_group(SensorAInput, SensorBInput)]
    temperature: i32,
    #[variant_group(SensorBInput)]
    weight: i32,
    // no attribute on d means no enum variant will include d.
    d: i32,
}
// `EnumUpdate` will generate
// pub enum MyStateUpdate {
//     SensorAInput { speed: i32, temperature: i32 },
//     SensorBInput { temperature: i32, weight: i32 },
// }
```
## `EnumUpdateSetters`

### Basic example

```rust
use enum_update::*;
#[derive(Debug, PartialEq, EnumUpdate, EnumUpdateSetters)]
pub struct MyState {
    #[variant_group]
    value: String,
}
// `EnumUpdateSetters` will generate:
// impl MyState {
//     fn modify_value(&mut self, value: String) -> MyStateUpdate {
//         self.value = value.clone();
//         MystateUpdate { value }
//     }
// }
let mut state: MyState<'static> = MyState {
    value: "hello".to_string(),
};
state.modify_my_reference("enum updates");
assert_eq!(state, MyState {
    value: "hello".to_string(),
});
```

# Contributing

Contributions and bug fixes are always welcome. Please open an issue first before implementing a feature or fixing a bug. It is possible that I am already implementing it locally.
